# 模块：ui（表现层与交互入口）

## 系统概述 (System Overview)

ui 模块负责将玩家交互转换为 `Command` 并驱动 `GameEngine`，同时把 `GameState` 的快照渲染为可视化界面。它不直接实现规则，而是作为“命令生产者 + 状态消费者”。其正确性重点在于：不绕过引擎修改状态、并能在状态变化后可靠刷新 UI。

## 静态结构图 (PlantUML)

```plantuml
@startuml
title UI：场景脚本与引擎交互

hide empty members
skinparam packageStyle rectangle

package "ui/scenes/setup" {
  class GameSetupScene <<Control>> {
    +_on_start_pressed()
  }
}

package "ui/scenes/game" {
  class GameScene <<Control>> {
    -game_engine: GameEngine
    -_initialize_game()
    -_execute_command(cmd): Result
    -_update_ui()
    +_on_advance_phase_pressed()
    +_on_skip_pressed()
  }
}

package "autoload" {
  class Globals
  class SceneManager
}

package "core/types" {
  class Command
  class Result
}

package "core/engine" {
  class GameEngine
}

GameSetupScene ..> Globals : write settings
GameSetupScene ..> SceneManager : goto_game()

GameScene ..> Globals : read config\nstore engine ref
GameScene ..> GameEngine : initialize/execute
GameScene ..> Command : create(action_id, actor, params)
GameScene ..> Result : handle ok/error
@enduml
```

## 核心流程图 (PlantUML Sequence)

典型场景：**GameScene 执行一次系统命令 `advance_phase` 并刷新 UI**。

```plantuml
@startuml
title UI 典型场景：按钮触发 advance_phase

actor Player as P
participant "UI(GameScene)" as UI
participant "Command" as CMD
participant "GameEngine" as GE
participant "GameState" as GS

P -> UI : 点击“推进阶段”
UI -> CMD : create_system("advance_phase")
UI -> GE : execute_command(cmd)
GE --> UI : Result(state)
UI -> GS : read state (GE.get_state())
UI -> UI : _update_ui()\n(回合/阶段/银行/地图)
@enduml
```

## 状态机/逻辑流 (Mermaid)

UI 侧可以理解为“场景生命周期 + 引擎就绪状态”，复杂状态切换主要在 core 的 `PhaseManager`，UI 只需要跟随状态展示。

```mermaid
stateDiagram-v2
  [*] --> Uninitialized
  Uninitialized --> Ready : _initialize_game() / GameEngine.initialize()
  Ready --> Ready : execute_command() / _update_ui()
  Ready --> [*] : quit to menu / Globals.reset_game_config()
```

## 设计模式与要点 (Design Insights)

- **MVC-ish 分层**：UI 作为 View/Controller，规则在 core/gameplay；`GameState` 是唯一可信 Model。
- **命令驱动**：UI 不应直接改 `GameState`，只应构造 `Command` 交给 `GameEngine`。

维护要点：

1. 任何 UI 新功能（新按钮/新交互）优先落到“新增/复用 action_id + params”，而不是在 UI 里写规则分支。
2. `GameScene._update_ui()` 读取 `GameState` 的字段/键名耦合很强，修改 schema 时要同步更新 UI 显示逻辑。
3. 地图渲染通过 `map_view.call("set_game_state", state)` 反射调用，需保持 `MapView` 的接口稳定（否则运行期才暴露错误）。

潜在耦合风险：

- UI 直接持有 `GameEngine` 并写入 `Globals.current_game_engine`，未来若引入“回放/观战/沙盒对局”多实例，会逼迫 UI 改造为显式传递对局上下文而非依赖 Globals。
